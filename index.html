<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Loggex by philosodad</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Loggex</h1>
        <p>An example project using Ecto and Plug.Router</p>

        <p class="view"><a href="https://github.com/philosodad/loggex">View the Project on GitHub <small>philosodad/loggex</small></a></p>


        <ul>
          <li><a href="https://github.com/philosodad/loggex/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/philosodad/loggex/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/philosodad/loggex">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p>I've been working with a couple of Elixir technologies lately, Plug.Router and Ecto, and I'm pretty pleased with how easy it is to get them working together. Here's an example -- let's say I want to write a logger. The logger takes in whatever message hits it's log endpoint and writes it to a database. We'll write a proof of concept logger in this post, <a href="https://github.com/philosodad/loggex">you can find the code on GitHub</a>. Occasionally you'll see a cryptic note like this <a href="https://github.com/philosodad/loggex">[s0]</a>, that is an indication that the code up to that point is available under the indicated tag. </p>

<p>If you want to follow along with this exercise, you're going to need to have elixir and postgresql installed on your computer, or if you are a user of vagrant, you can try a prebuilt box for phoenix development like <a href="https://github.com/kiere/vagrant-phoenix-postgres">this one</a>. I haven't tried that box, but it's worth a shot.</p>

<p>We're going to use the logger to record the time the original message was received, the response code for the message, and the body of the message. So my endpoint is going to expect a block of JSON that looks something like this:</p>

<pre><code>{ 
  sender: "something.com" 
  time: &lt;datetime&gt;, 
  responseCode: 300, 
  body: "\{\"foo\": \"bar\"\}"
}
</code></pre>

<p>And we're going to put that into a postgres database in a table that's called "messages".</p>

<p>So, we'll need to start a new elixir project:</p>

<pre><code>$ mix new loggex
$ cd loggex
</code></pre>

<p>And add some dependencies to the <code>mix.exs</code> file. We'll need to add cowboy, plug, ecto, and postgrex:</p>

<pre><code>def application do
  [applications: 
    [:logger,
     :cowboy,
     :plug,
     :postgrex,
     :ecto]
  ]
end 
defp deps do
  [
    {:httpoison, "~&gt; 0.8.0"},
    {:cowboy, "~&gt; 1.0.0"},
    {:plug, "~&gt; 1.0"},
    {:exjsx, "~&gt; 3.2"},
    {:postgrex, "&gt;= 0.0.0"},
    {:ecto, "~&gt; 1.1.2"}
  ]
end
</code></pre>

<p><a href="https://github.com/philosodad/loggex/tree/s1">[s1]</a><a href="https://github.com/elixir-lang/plug">Plug</a> is the middleware framework that contains Plug.Router, <a href="https://github.com/ninenines/cowboy">Cowboy</a> is a web server from Erlang, <a href="https://github.com/elixir-lang/ecto">Ecto</a> is the database wrapper and <a href="https://github.com/ericmj/postgrex">Postgrex</a> is the adapter between Ecto and Postgres. We could use a different database, there are several adapters available, but Postgres is sort of the defacto standard so we'll stick with it. Of course, once you have those dependencies noted you'll want to run <code>mix deps.get</code> to install them all.</p>

<p>Now that we're set up, we'll first add a route, then add the database migration, then wire it together to save the incoming message to the database. A quick side note, I'll be driving this with tests on my side but not including them in the post. The tests are in the GitHub repo, though.</p>

<p>Adding a route looks pretty simple, if you're familiar with Sinatra this probably looks familiar to you:</p>

<pre><code>defmodule Loggex do
  use Plug.Router
  plug :match
  plug :dispatch

  post "/log" do
    send_resp(conn, 200, "No Response")
  end
end
</code></pre>

<p>To start the router, use <code>iex -S mix</code> to start an iex session, and in iex:</p>

<pre><code>&gt; Plug.Adapters.Cowboy.http Loggex, [], port: 6438
</code></pre>

<p>The port option is optional, it defaults to 4000. I have about six servers running on my laptop right now, so I'm getting creative with port numbers. In a later post we might look at how to make these values configurable, as well as how to start the server from the command line rather than from iex.</p>

<p>At this point, if you send an http request to <code>localhost:6438/log</code>, you should receive a 200 response back<a href="https://github.com/philosodad/loggex/tree/s2">[s2]</a>.</p>

<p>Next, we want to set up the database with ecto. Ecto has it's own mix tasks, which makes this somewhat easier.</p>

<pre><code>$ mix ecto.gen.repo
</code></pre>

<p>This will generate a new file in <code>lib/loggex/</code> called <code>repo.ex</code>. You don't have to do anything to the repo file, but there are also changes to be made to your <code>config.exs</code> file. That file will now have some new material in it:</p>

<pre><code>use Mix.Config
config :loggex, Loggex.Repo,
  adapter: Ecto.Adapters.Postgres,
  database: "loggex_repo",
  username: "user", #CHANGE THIS LINE
  password: "pass", #CHANGE THIS LINE
  hostname: "localhost"
</code></pre>

<p>The <code>username</code> and <code>password</code> entries will need to be changed to a user on your installation of postgres. Once we have a repository, we can create the repository and generate a migration.</p>

<pre><code>:::bash
$ mix ecto.create
$ mix ecto.gen.migration add_loglines_table
</code></pre>

<p>This produces a basic migration file in <code>priv/repo/migrations/</code> which we'll edit to match the JSON schema we started with:</p>

<pre><code>defmodule Loggex.Repo.Migrations.AddLoglinesTable do
  use Ecto.Migration
  def change do
    create table(:loglines) do
      add :sender, :string
      add :sendtime, :datetime
      add :responseCode, :integer
      add :body, :string
    end
  end
end            
</code></pre>

<p>The <code>change</code> function is automatically reversible. Now, in order to be able to work effeciently with our new database and table, we'll want to add a schema at <code>lib/loggex/logline.ex</code>.</p>

<pre><code>defmodule Loggex.Logline do
  use Ecto.Schema
  import Ecto.Changeset

  schema "loglines" do
    field :sender, :string
    field :sendtime, Ecto.DateTime
    field :responseCode, :integer
    field :body, :string
  end
end                
</code></pre>

<p>At this point, using iex, you should be able to start the repo with <code>Loggex.Repo.start_link</code> and insert a changeset into the repo. I put a lot of trial and error in, so here's an example iex session. Some of the longer lines have been moved to multiple lines, so you'll want to fix the query, it may not run if just pasted in.</p>

<pre><code>ex(1)&gt; {:ok, repo} = Loggex.Repo.start_link
{:ok, #PID&lt;0.214.0&gt;}
iex(2)&gt; change = %Loggex.Logline{sender: "sender",
                      sendtime: Ecto.DateTime.utc,
                      responseCode: 344,
                      body: "body goes here"}
%Loggex.Logline{__meta__: #Ecto.Schema.Metadata&lt;:built&gt;
iex(3)&gt; import Ecto.Query
nil
iex(4)&gt; Loggex.Repo.insert change

16:16:38.577 [debug] INSERT INTO "loglines" ("body", "re
{:ok,
 %Loggex.Logline{__meta__: #Ecto.Schema.Metadata&lt;:loaded
  body: "body goes here", id: 3, responseCode: 344, send
  sendtime: #Ecto.DateTime&lt;2016-02-21T21:15:54Z&gt;}}
iex(5)&gt; query = from l in Loggex.Logline, 
                 where: l.responseCode == 344, 
                 select: l
#Ecto.Query&lt;from l in Loggex.Logline, where: l.responseC
iex(6)&gt; Loggex.Repo.one query

16:17:45.614 [debug] SELECT l0."id", l0."sender", l0."se
%Loggex.Logline{__meta__: #Ecto.Schema.Metadata&lt;:loaded&gt;
 body: "body goes here", id: 3, responseCode: 344, sende
 sendtime: #Ecto.DateTime&lt;2016-02-21T21:15:54Z&gt;}
iex(7)&gt; log = Loggex.Repo.one query

16:18:00.319 [debug] SELECT l0."id", l0."sender", l0."se
%Loggex.Logline{__meta__: #Ecto.Schema.Metadata&lt;:loaded&gt;
 body: "body goes here", id: 3, responseCode: 344, sende
 sendtime: #Ecto.DateTime&lt;2016-02-21T21:15:54Z&gt;}
iex(8)&gt; log.responseCode
344
</code></pre>

<p>All the parts are here at this point<a href="https://github.com/philosodad/loggex/tree/s3">[s3]</a>, we just need to make them work together. Now, I'm fairly sure that there are better ways to do this than the way I've settled on. In particular, I'm doing some pretty gunky stuff to convert the input into a <code>%Loggex.Logline struct</code>. But here goes.</p>

<p>My first problem is that I've got a requirement to send in an Ecto.DateTime object, but I'll probably be receiving an iso datetime string. We'll take advantage of plug to handle this (again, this is just an example, this probably should go in the Schema).</p>

<pre><code>defmodule Loggex do
  use Plug.Router
  use Plug.Builder

  plug Plug.Parsers, parsers: [:json, :urlencoded],
                     json_decoder: JSX
  plug :timefixer
  plug :match
  plug :dispatch

  def start do
    Plug.Adapters.Cowboy.http Loggex, [], port: 6438
    Loggex.Repo.start_link
  end

  def stop do
    Plug.Adapters.Cowboy.shutdown Loggex.HTTP
  end

  post "/log" do
    Map.keys(conn.params)
    |&gt; Enum.reduce(%{}, fn(k,acc) -&gt; 
       Map.put(acc, String.to_atom(k), conn.params[k]) 
       end)
    |&gt; (&amp;(Map.merge(%Loggex.Logline{}, &amp;1))).()
    |&gt; Loggex.Repo.insert
    send_resp(conn, 200, "No Response")
  end

  def timefixer conn, opts do
    conn = conn.params["sendtime"]
    |&gt; Ecto.DateTime.cast!
    |&gt; (&amp;(Map.put(conn.params, "sendtime", &amp;1))).()
    |&gt; (&amp;(Map.put(conn, :params, &amp;1))).()
    conn
  end

end
</code></pre>

<p>Let's walk through the plug pipeline one step at a time. The first plug is the JSON parser. It takes in a conn struct, reads the input body, and returns a new conn with a <code>params</code> key, the value of which is a map built from the input JSON.</p>

<p>We added <code>Plug.Builder</code> and a new plug, <code>:timefixer</code>, which we define as a function in the module. Time fixer takes the conn struct that the JSON parser returns and typecasts the <code>"sendtime"</code> value of the <code>conn.params</code> into an <code>Ecto.DateTime</code> struct, which is what the schema expects. The new conn is passed on to the <code>:match</code> plug.</p>

<p>The <code>:match</code> plug matches the incoming request to the <code>post "/log"</code> function, where we convert the params that came in into a <code>%Loggex.Logline{}</code> struct, so that we can insert that into the database. Again, we make pretty heavy use of the pipeline operator here. After inserting the new logline into the database, we return three values, the conn, a response code, and a message. These are passed to the <code>:dispatch</code> plug, which returns a 200 to the user. </p>

<p>At this point we have a functional logger<a href="https://github.com/philosodad/loggex/tree/s4">[s4]</a>. It isn't as pretty as it could be, and it definitely needs a little cleanup and some error handling, but provided it gets exactly the right inputs, it will save a logline into the postgres database.</p>

<p>Next entry I'll look at how to improve this project by adding configuration, CI, and test coverage metrics. And of course you can find the code on GitHub, <a href="https://github.com/philosodad/loggex">https://github.com/philosodad/loggex</a>.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/philosodad">philosodad</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
